<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>让使用Apache的网站速度更快 | 老高的技术博客</title><meta name=keywords content="apache"><meta name=description content="Apache 2.0在性能上的改善最吸引人.在支持POSIX线程的Unix系统上,Apache可以通过不同的MPM运行在一种多进程与多线程相混合的模式下,增强部分配置的可扩充性能.相比于Apache 1.3,2.0版本做了大量的优化来提升处理能力和可伸缩性,并且大多数改进在默认状态下即可生效.但是在编译和运行时刻,2.0也有许多可以显著提高性能的选择.
MPM（Multi -Processing Modules,多道处理模块） MPM是Apache2.0中影响性能的最核心特性.
毫不夸张地说,MPM的引入是Apache 2.0最重要的变化.大家知道,Apache是基于模块化的设计,而Apache 2.0更扩展了模块化设计到Web服务器的最基本功能.服务器装载了一种多道处理模块,负责绑定本机网络端口、接受请求,并调度子进程来处理请求.扩展模块化设计有两个重要好处:
 apache可以更简洁、有效地支持多种操作系统; 务器可以按站点的特殊需要进行自定制.  在用户级,MPM看起来和其它Apache模块非常类似.主要区别是在任意时刻只能有一种MPM被装载到服务器中. 下面以Linux RedHat AS3为平台,演示一下在Apache 2.0中如何指定MPM.
# wget http://archive.apache.org/dist/httpd/httpd-2.0.52.tar.bz2 # tar jxvf httpd-2.0.52.tar.bz2 # cd httpd-2.0.52 # ./configure ——help|grep mpm  显示如下:
——with-mpm=MPM Choose the process model for Apache to use. MPM={beos|worker|prefork|mpmt\_os2| perchild|leader|threadpool}  上述操作用来选择要使用的进程模型,即哪种MPM模块.Beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM, perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程.这在运行多个需要CGI的虚拟主机时特别有用,会比1.3版中的SuExec 机制做得更好.leader和threadpool都是基于worker的变体,还处于实验性阶段,某些情况下并不会按照预期设想的那样工作,所以 Apache官方也并不推荐使用.因此,我们主要阐述prefork和worker这两种和性能关系最大的产品级MPM.
prefork的工作原理 如果不用“——with-mpm”显式指定某种MPM,prefork就是Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程,2.0版使用它是为了与1.3版保持兼容性;另一方面,prefork用单独的子进程来处理不同的请求,进程之间是彼此独立的,这也使其成为最稳定的MPM之一.
prefork的工作原理是,控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟,继续创建两个,再等待一秒钟,继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个,直到满足 MinSpareServers设置的值为止.这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程,从而减小了系统开销以增加性能.
worker的工作原理 相对于prefork,worker是2.0 版中全新的支持多线程和多进程混合模型的MPM.由于使用线程来处理,所以可以处理相对海量的请求,而系统资源的开销要小于基于进程的服务器.但是, worker也使用了多进程,每个进程又生成多个线程,以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.0的发展趋势. worker的工作原理是,由主控制进程生成“StartServers”个子进程,每个子进程中包含固定的ThreadsPerChild 线程数,各个线程独立地处理请求.同样,为了不在请求到来时再生成线程,MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数;而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载,控制进程将派生新的子进程.
下面我以worker模式进行编译安装
# ./configure --prefix=/usr/local/apache --with-mpm=worker --enable-so# #注释（让它支持DSO功能,这样以后可以动态加载模块）# make# make install# cd /usr/local/apache/conf# vi httpd."><meta name=author content="Me"><link rel=canonical href=https://phpgao.github.io/faster_apache.html><link crossorigin=anonymous href=/assets/css/stylesheet.min.1a6ee89730e13a801d0f34e0cb5b98e96cf8c65b80500638bd599fc224ed8442.css integrity="sha256-Gm7olzDhOoAdDzTgy1uY6Wz4xluAUAY4vVmfwiTthEI=" rel="preload stylesheet" as=style><link rel=preload href="https://cdn.v2ex.com/gravatar/2b66f45a3e2f41db6522381006bfaea1?s=192" as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://phpgao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://phpgao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://phpgao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://phpgao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://phpgao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-39288145-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="让使用Apache的网站速度更快"><meta property="og:description" content="Apache 2.0在性能上的改善最吸引人.在支持POSIX线程的Unix系统上,Apache可以通过不同的MPM运行在一种多进程与多线程相混合的模式下,增强部分配置的可扩充性能.相比于Apache 1.3,2.0版本做了大量的优化来提升处理能力和可伸缩性,并且大多数改进在默认状态下即可生效.但是在编译和运行时刻,2.0也有许多可以显著提高性能的选择.
MPM（Multi -Processing Modules,多道处理模块） MPM是Apache2.0中影响性能的最核心特性.
毫不夸张地说,MPM的引入是Apache 2.0最重要的变化.大家知道,Apache是基于模块化的设计,而Apache 2.0更扩展了模块化设计到Web服务器的最基本功能.服务器装载了一种多道处理模块,负责绑定本机网络端口、接受请求,并调度子进程来处理请求.扩展模块化设计有两个重要好处:
 apache可以更简洁、有效地支持多种操作系统; 务器可以按站点的特殊需要进行自定制.  在用户级,MPM看起来和其它Apache模块非常类似.主要区别是在任意时刻只能有一种MPM被装载到服务器中. 下面以Linux RedHat AS3为平台,演示一下在Apache 2.0中如何指定MPM.
# wget http://archive.apache.org/dist/httpd/httpd-2.0.52.tar.bz2 # tar jxvf httpd-2.0.52.tar.bz2 # cd httpd-2.0.52 # ./configure ——help|grep mpm  显示如下:
——with-mpm=MPM Choose the process model for Apache to use. MPM={beos|worker|prefork|mpmt\_os2| perchild|leader|threadpool}  上述操作用来选择要使用的进程模型,即哪种MPM模块.Beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM, perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程.这在运行多个需要CGI的虚拟主机时特别有用,会比1.3版中的SuExec 机制做得更好.leader和threadpool都是基于worker的变体,还处于实验性阶段,某些情况下并不会按照预期设想的那样工作,所以 Apache官方也并不推荐使用.因此,我们主要阐述prefork和worker这两种和性能关系最大的产品级MPM.
prefork的工作原理 如果不用“——with-mpm”显式指定某种MPM,prefork就是Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程,2.0版使用它是为了与1.3版保持兼容性;另一方面,prefork用单独的子进程来处理不同的请求,进程之间是彼此独立的,这也使其成为最稳定的MPM之一.
prefork的工作原理是,控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟,继续创建两个,再等待一秒钟,继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个,直到满足 MinSpareServers设置的值为止.这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程,从而减小了系统开销以增加性能.
worker的工作原理 相对于prefork,worker是2.0 版中全新的支持多线程和多进程混合模型的MPM.由于使用线程来处理,所以可以处理相对海量的请求,而系统资源的开销要小于基于进程的服务器.但是, worker也使用了多进程,每个进程又生成多个线程,以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.0的发展趋势. worker的工作原理是,由主控制进程生成“StartServers”个子进程,每个子进程中包含固定的ThreadsPerChild 线程数,各个线程独立地处理请求.同样,为了不在请求到来时再生成线程,MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数;而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载,控制进程将派生新的子进程.
下面我以worker模式进行编译安装
# ./configure --prefix=/usr/local/apache --with-mpm=worker --enable-so# #注释（让它支持DSO功能,这样以后可以动态加载模块）# make# make install# cd /usr/local/apache/conf# vi httpd."><meta property="og:type" content="article"><meta property="og:url" content="https://phpgao.github.io/faster_apache.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-04-20T15:45:00+00:00"><meta property="article:modified_time" content="2014-04-20T15:45:00+00:00"><meta property="og:site_name" content="老高的技术博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="让使用Apache的网站速度更快"><meta name=twitter:description content="Apache 2.0在性能上的改善最吸引人.在支持POSIX线程的Unix系统上,Apache可以通过不同的MPM运行在一种多进程与多线程相混合的模式下,增强部分配置的可扩充性能.相比于Apache 1.3,2.0版本做了大量的优化来提升处理能力和可伸缩性,并且大多数改进在默认状态下即可生效.但是在编译和运行时刻,2.0也有许多可以显著提高性能的选择.
MPM（Multi -Processing Modules,多道处理模块） MPM是Apache2.0中影响性能的最核心特性.
毫不夸张地说,MPM的引入是Apache 2.0最重要的变化.大家知道,Apache是基于模块化的设计,而Apache 2.0更扩展了模块化设计到Web服务器的最基本功能.服务器装载了一种多道处理模块,负责绑定本机网络端口、接受请求,并调度子进程来处理请求.扩展模块化设计有两个重要好处:
 apache可以更简洁、有效地支持多种操作系统; 务器可以按站点的特殊需要进行自定制.  在用户级,MPM看起来和其它Apache模块非常类似.主要区别是在任意时刻只能有一种MPM被装载到服务器中. 下面以Linux RedHat AS3为平台,演示一下在Apache 2.0中如何指定MPM.
# wget http://archive.apache.org/dist/httpd/httpd-2.0.52.tar.bz2 # tar jxvf httpd-2.0.52.tar.bz2 # cd httpd-2.0.52 # ./configure ——help|grep mpm  显示如下:
——with-mpm=MPM Choose the process model for Apache to use. MPM={beos|worker|prefork|mpmt\_os2| perchild|leader|threadpool}  上述操作用来选择要使用的进程模型,即哪种MPM模块.Beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM, perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程.这在运行多个需要CGI的虚拟主机时特别有用,会比1.3版中的SuExec 机制做得更好.leader和threadpool都是基于worker的变体,还处于实验性阶段,某些情况下并不会按照预期设想的那样工作,所以 Apache官方也并不推荐使用.因此,我们主要阐述prefork和worker这两种和性能关系最大的产品级MPM.
prefork的工作原理 如果不用“——with-mpm”显式指定某种MPM,prefork就是Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程,2.0版使用它是为了与1.3版保持兼容性;另一方面,prefork用单独的子进程来处理不同的请求,进程之间是彼此独立的,这也使其成为最稳定的MPM之一.
prefork的工作原理是,控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟,继续创建两个,再等待一秒钟,继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个,直到满足 MinSpareServers设置的值为止.这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程,从而减小了系统开销以增加性能.
worker的工作原理 相对于prefork,worker是2.0 版中全新的支持多线程和多进程混合模型的MPM.由于使用线程来处理,所以可以处理相对海量的请求,而系统资源的开销要小于基于进程的服务器.但是, worker也使用了多进程,每个进程又生成多个线程,以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.0的发展趋势. worker的工作原理是,由主控制进程生成“StartServers”个子进程,每个子进程中包含固定的ThreadsPerChild 线程数,各个线程独立地处理请求.同样,为了不在请求到来时再生成线程,MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数;而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载,控制进程将派生新的子进程.
下面我以worker模式进行编译安装
# ./configure --prefix=/usr/local/apache --with-mpm=worker --enable-so# #注释（让它支持DSO功能,这样以后可以动态加载模块）# make# make install# cd /usr/local/apache/conf# vi httpd."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://phpgao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"让使用Apache的网站速度更快","item":"https://phpgao.github.io/faster_apache.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"让使用Apache的网站速度更快","name":"让使用Apache的网站速度更快","description":"Apache 2.0在性能上的改善最吸引人.在支持POSIX线程的Unix系统上,Apache可以通过不同的MPM运行在一种多进程与多线程相混合的模式下,增强部分配置的可扩充性能.相比于Apache 1.3,2.0版本做了大量的优化来提升处理能力和可伸缩性,并且大多数改进在默认状态下即可生效.但是在编译和运行时刻,2.0也有许多可以显著提高性能的选择.\nMPM（Multi -Processing Modules,多道处理模块） MPM是Apache2.0中影响性能的最核心特性.\n毫不夸张地说,MPM的引入是Apache 2.0最重要的变化.大家知道,Apache是基于模块化的设计,而Apache 2.0更扩展了模块化设计到Web服务器的最基本功能.服务器装载了一种多道处理模块,负责绑定本机网络端口、接受请求,并调度子进程来处理请求.扩展模块化设计有两个重要好处:\n apache可以更简洁、有效地支持多种操作系统; 务器可以按站点的特殊需要进行自定制.  在用户级,MPM看起来和其它Apache模块非常类似.主要区别是在任意时刻只能有一种MPM被装载到服务器中. 下面以Linux RedHat AS3为平台,演示一下在Apache 2.0中如何指定MPM.\n# wget http://archive.apache.org/dist/httpd/httpd-2.0.52.tar.bz2 # tar jxvf httpd-2.0.52.tar.bz2 # cd httpd-2.0.52 # ./configure ——help|grep mpm  显示如下:\n——with-mpm=MPM Choose the process model for Apache to use. MPM={beos|worker|prefork|mpmt\\_os2| perchild|leader|threadpool}  上述操作用来选择要使用的进程模型,即哪种MPM模块.Beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM, perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程.这在运行多个需要CGI的虚拟主机时特别有用,会比1.3版中的SuExec 机制做得更好.leader和threadpool都是基于worker的变体,还处于实验性阶段,某些情况下并不会按照预期设想的那样工作,所以 Apache官方也并不推荐使用.因此,我们主要阐述prefork和worker这两种和性能关系最大的产品级MPM.\nprefork的工作原理 如果不用“——with-mpm”显式指定某种MPM,prefork就是Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程,2.0版使用它是为了与1.3版保持兼容性;另一方面,prefork用单独的子进程来处理不同的请求,进程之间是彼此独立的,这也使其成为最稳定的MPM之一.\nprefork的工作原理是,控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟,继续创建两个,再等待一秒钟,继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个,直到满足 MinSpareServers设置的值为止.这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程,从而减小了系统开销以增加性能.\nworker的工作原理 相对于prefork,worker是2.0 版中全新的支持多线程和多进程混合模型的MPM.由于使用线程来处理,所以可以处理相对海量的请求,而系统资源的开销要小于基于进程的服务器.但是, worker也使用了多进程,每个进程又生成多个线程,以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.0的发展趋势. worker的工作原理是,由主控制进程生成“StartServers”个子进程,每个子进程中包含固定的ThreadsPerChild 线程数,各个线程独立地处理请求.同样,为了不在请求到来时再生成线程,MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数;而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载,控制进程将派生新的子进程.\n下面我以worker模式进行编译安装\n# ./configure --prefix=/usr/local/apache --with-mpm=worker --enable-so\r# #注释（让它支持DSO功能,这样以后可以动态加载模块）\r# make\r# make install\r# cd /usr/local/apache/conf\r# vi httpd.","keywords":["apache"],"articleBody":"Apache 2.0在性能上的改善最吸引人.在支持POSIX线程的Unix系统上,Apache可以通过不同的MPM运行在一种多进程与多线程相混合的模式下,增强部分配置的可扩充性能.相比于Apache 1.3,2.0版本做了大量的优化来提升处理能力和可伸缩性,并且大多数改进在默认状态下即可生效.但是在编译和运行时刻,2.0也有许多可以显著提高性能的选择.\nMPM（Multi -Processing Modules,多道处理模块） MPM是Apache2.0中影响性能的最核心特性.\n毫不夸张地说,MPM的引入是Apache 2.0最重要的变化.大家知道,Apache是基于模块化的设计,而Apache 2.0更扩展了模块化设计到Web服务器的最基本功能.服务器装载了一种多道处理模块,负责绑定本机网络端口、接受请求,并调度子进程来处理请求.扩展模块化设计有两个重要好处:\n apache可以更简洁、有效地支持多种操作系统; 务器可以按站点的特殊需要进行自定制.  在用户级,MPM看起来和其它Apache模块非常类似.主要区别是在任意时刻只能有一种MPM被装载到服务器中. 下面以Linux RedHat AS3为平台,演示一下在Apache 2.0中如何指定MPM.\n# wget http://archive.apache.org/dist/httpd/httpd-2.0.52.tar.bz2 # tar jxvf httpd-2.0.52.tar.bz2 # cd httpd-2.0.52 # ./configure ——help|grep mpm  显示如下:\n——with-mpm=MPM Choose the process model for Apache to use. MPM={beos|worker|prefork|mpmt\\_os2| perchild|leader|threadpool}  上述操作用来选择要使用的进程模型,即哪种MPM模块.Beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM, perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程.这在运行多个需要CGI的虚拟主机时特别有用,会比1.3版中的SuExec 机制做得更好.leader和threadpool都是基于worker的变体,还处于实验性阶段,某些情况下并不会按照预期设想的那样工作,所以 Apache官方也并不推荐使用.因此,我们主要阐述prefork和worker这两种和性能关系最大的产品级MPM.\nprefork的工作原理 如果不用“——with-mpm”显式指定某种MPM,prefork就是Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程,2.0版使用它是为了与1.3版保持兼容性;另一方面,prefork用单独的子进程来处理不同的请求,进程之间是彼此独立的,这也使其成为最稳定的MPM之一.\nprefork的工作原理是,控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟,继续创建两个,再等待一秒钟,继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个,直到满足 MinSpareServers设置的值为止.这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程,从而减小了系统开销以增加性能.\nworker的工作原理 相对于prefork,worker是2.0 版中全新的支持多线程和多进程混合模型的MPM.由于使用线程来处理,所以可以处理相对海量的请求,而系统资源的开销要小于基于进程的服务器.但是, worker也使用了多进程,每个进程又生成多个线程,以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.0的发展趋势. worker的工作原理是,由主控制进程生成“StartServers”个子进程,每个子进程中包含固定的ThreadsPerChild 线程数,各个线程独立地处理请求.同样,为了不在请求到来时再生成线程,MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数;而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载,控制进程将派生新的子进程.\n下面我以worker模式进行编译安装\n# ./configure --prefix=/usr/local/apache --with-mpm=worker --enable-so\r# #注释（让它支持DSO功能,这样以后可以动态加载模块）\r# make\r# make install\r# cd /usr/local/apache/conf\r# vi httpd.conf\rStartServers 2 MaxClients\r150 ServerLimit 25 MinSpareThreads\r25 MaxSpareThreads 75 ThreadLimit\r25 ThreadsPerChild 25 MaxRequestsPerChild 0\r Worker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild值决定的,应该大于等于MaxClients.如果负载很大,现有的子进程数不能满足时,控制进程会派生新的子进程.默认最大的子进程总数是16,加大时也需要显式声明ServerLimit（最大值是20000）\n需要注意的是,如果显式声明了ServerLimit,那么它乘以ThreadsPerChild的值必须大于等于MaxClients,而且MaxClients必须是ThreadsPerChild的整数倍,否则Apache将会自动调节到一个相应值（可能是个非期望值）.下面是笔者的 worker配置段: StartServers 3 MaxClients 2000 ServerLimit 25 MinSpareThreads 50 MaxSpareThreads 200 ThreadLimit 200 ThreadsPerChild 100 MaxRequestsPerChild 0 \r# 保存退出. # /usr/local/apache/bin/apachectl start # 可根据实际情况来配置Apache相关的核心参数,以获得最大的性能和稳定性.  限制Apache并发连接数 我们知道当网站以http方式提供软件下载时,若是每个用户都开启多个线程并没有带宽的限制,将很快达到http的最大连接数或者造成网络阻塞,使得网站的许多正常服务都无法运行.下面我们添加mod_limitipconn模块,来控制http的并发连接数.\n# wget http://dominia.org/djao/limit/mod_limitipconn-0.22.tar.gz\r# tar zxvf mod_limitipconn-0.22.tar.gz\r# cd mod_limitipconn-0.22\r# /usr/local/apache/bin/ apxs -c -i -a mod_limitipconn.c\r# 编译好后会自动把mod_rewrite.so拷贝到/usr/local/apache/modules下,并修改你的httpd.conf文件.\r# vi /usr/local/apache/conf/httpd.conf\r# 在最后一行加入\r#所限制的目录所在,此处表示主机的根目录MaxConnPerIP 2\r#所限制的每个IP并发连接数为2个\r# 保存退出.\r# /usr/local/apache/bin/apachectl start\r 我们刚才已经限制了IP并发数,但如果对方把链接盗链到别的页面,我们刚才做的就毫无意义了,因为他完全可以通过蚂蚁或快车进行下载.所以就这种情况,我们要引用mod_rewrite.so模块.这样,当他盗链了文件,通过mod_rewrite.so模块把页面引到了一个事先我们制定好的错误页面里,这样就防止了盗链。\n# /usr/local/apache/bin/apxs -c -i -a /opt/httpd-2.0.52/modules/mappers/mod_rewrite.c\r# 编译好后会自动把mod_rewrite.so拷贝到/usr/local/apache/modules下,并修改你的httpd.conf文件.\r# vi /usr/local/apache/conf/httpd.conf\rRewriteEngine onRewriteCond %{HTTP_REFERER} !\r^http://www.squall.cn/.*$ [NC]RewriteCond %{HTTP_REFERER} !\r^http://www.squall.cn$ [NC]RewriteCond %{HTTP_REFERER} !\r^http://squall.cn/.*$ [NC]RewriteCond %{HTTP_REFERER} !\r^http://squall.cn$ [NC]RewriteRule .*\\\\.\r(jpg|gif|png|bmp|tar|gz|rar|zip|exe)$\rhttp://www.squall.cn/error.htm [R,NC]\r 到此,我们就对Apache做了一次全面优化,性能比原来明显地有了很大的提高.这次实施过程到此也就圆满的结束了.相信大家通过读完我的这篇文章后,对Apache优化也有了一些心得,相信你在工作中也会处理好突发事件。\n","wordCount":"193","inLanguage":"en","datePublished":"2014-04-20T15:45:00Z","dateModified":"2014-04-20T15:45:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://phpgao.github.io/faster_apache.html"},"publisher":{"@type":"Organization","name":"老高的技术博客","logo":{"@type":"ImageObject","url":"https://phpgao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://phpgao.github.io/ accesskey=h title="老高的博客 (Alt + H)">老高的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://phpgao.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://phpgao.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://blog.phpgao.com title="old blog"><span>old blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://phpgao.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://phpgao.github.io/posts/>Posts</a></div><h1 class=post-title>让使用Apache的网站速度更快</h1><div class=post-meta>April 20, 2014&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2014-04-20_faster_apache.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Apache 2.0在性能上的改善最吸引人.在支持POSIX线程的Unix系统上,Apache可以通过不同的MPM运行在一种多进程与多线程相混合的模式下,增强部分配置的可扩充性能.相比于Apache 1.3,2.0版本做了大量的优化来提升处理能力和可伸缩性,并且大多数改进在默认状态下即可生效.但是在编译和运行时刻,2.0也有许多可以显著提高性能的选择.</p><h2 id=mpmmulti--processing-modules多道处理模块>MPM（Multi -Processing Modules,多道处理模块）<a hidden class=anchor aria-hidden=true href=#mpmmulti--processing-modules多道处理模块>#</a></h2><p>MPM是Apache2.0中影响性能的最核心特性.</p><p>毫不夸张地说,MPM的引入是Apache 2.0最重要的变化.大家知道,Apache是基于模块化的设计,而Apache 2.0更扩展了模块化设计到Web服务器的最基本功能.服务器装载了一种多道处理模块,负责绑定本机网络端口、接受请求,并调度子进程来处理请求.扩展模块化设计有两个重要好处:</p><ul><li>apache可以更简洁、有效地支持多种操作系统;</li><li>务器可以按站点的特殊需要进行自定制.</li></ul><p>在用户级,MPM看起来和其它Apache模块非常类似.主要区别是在任意时刻只能有一种MPM被装载到服务器中. 下面以Linux RedHat AS3为平台,演示一下在Apache 2.0中如何指定MPM.</p><pre><code># wget http://archive.apache.org/dist/httpd/httpd-2.0.52.tar.bz2 
# tar jxvf httpd-2.0.52.tar.bz2 
# cd httpd-2.0.52 
# ./configure ——help|grep mpm 
</code></pre><p>显示如下:</p><pre><code>——with-mpm=MPM Choose the process model for Apache to use. MPM={beos|worker|prefork|mpmt\_os2| perchild|leader|threadpool} 
</code></pre><p>上述操作用来选择要使用的进程模型,即哪种MPM模块.Beos、mpmt_os2分别是BeOS和OS/2上缺省的MPM, perchild主要设计目的是以不同的用户和组的身份来运行不同的子进程.这在运行多个需要CGI的虚拟主机时特别有用,会比1.3版中的SuExec 机制做得更好.leader和threadpool都是基于worker的变体,还处于实验性阶段,某些情况下并不会按照预期设想的那样工作,所以 Apache官方也并不推荐使用.因此,我们主要阐述prefork和worker这两种和性能关系最大的产品级MPM.</p><h3 id=prefork的工作原理>prefork的工作原理<a hidden class=anchor aria-hidden=true href=#prefork的工作原理>#</a></h3><p>如果不用“——with-mpm”显式指定某种MPM,prefork就是Unix平台上缺省的MPM.它所采用的预派生子进程方式也是 Apache 1.3中采用的模式.prefork本身并没有使用到线程,2.0版使用它是为了与1.3版保持兼容性;另一方面,prefork用单独的子进程来处理不同的请求,进程之间是彼此独立的,这也使其成为最稳定的MPM之一.</p><p>prefork的工作原理是,控制进程在最初建立“StartServers”个子进程后,为了满足MinSpareServers设置的需要创建一个进程,等待一秒钟,继续创建两个,再等待一秒钟,继续创建四个……如此按指数级增加创建的进程数,最多达到每秒32个,直到满足 MinSpareServers设置的值为止.这就是预派生（prefork）的由来.这种模式可以不必在请求到来时再产生新的进程,从而减小了系统开销以增加性能.</p><h3 id=worker的工作原理>worker的工作原理<a hidden class=anchor aria-hidden=true href=#worker的工作原理>#</a></h3><p>相对于prefork,worker是2.0 版中全新的支持多线程和多进程混合模型的MPM.由于使用线程来处理,所以可以处理相对海量的请求,而系统资源的开销要小于基于进程的服务器.但是, worker也使用了多进程,每个进程又生成多个线程,以获得基于进程服务器的稳定性.这种MPM的工作方式将是Apache 2.0的发展趋势.
worker的工作原理是,由主控制进程生成“StartServers”个子进程,每个子进程中包含固定的ThreadsPerChild 线程数,各个线程独立地处理请求.同样,为了不在请求到来时再生成线程,MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数;而MaxClients设置了所有子进程中的线程总数.如果现有子进程中的线程总数不能满足负载,控制进程将派生新的子进程.</p><p>下面我以worker模式进行编译安装</p><pre><code># ./configure --prefix=/usr/local/apache --with-mpm=worker --enable-so
# #注释（让它支持DSO功能,这样以后可以动态加载模块）
# make
# make install
# cd /usr/local/apache/conf
# vi httpd.conf
StartServers 2 MaxClients
150 ServerLimit 25 MinSpareThreads
25 MaxSpareThreads 75 ThreadLimit
25 ThreadsPerChild 25 MaxRequestsPerChild 0
</code></pre><p>Worker模式下所能同时处理的请求总数是由子进程总数乘以ThreadsPerChild值决定的,应该大于等于MaxClients.如果负载很大,现有的子进程数不能满足时,控制进程会派生新的子进程.默认最大的子进程总数是16,加大时也需要显式声明ServerLimit（最大值是20000）</p><p>需要注意的是,如果显式声明了ServerLimit,那么它乘以ThreadsPerChild的值必须大于等于MaxClients,而且MaxClients必须是ThreadsPerChild的整数倍,否则Apache将会自动调节到一个相应值（可能是个非期望值）.下面是笔者的 worker配置段:  </p><pre><code>&lt;IfModule worker.c&gt; 
StartServers 3 MaxClients 2000 ServerLimit 
25 MinSpareThreads 50 MaxSpareThreads 
200 ThreadLimit 200 ThreadsPerChild 
100 MaxRequestsPerChild 0 &lt;/IfModule&gt;&lt;/pre&gt;
# 保存退出. 
# /usr/local/apache/bin/apachectl start 
# 可根据实际情况来配置Apache相关的核心参数,以获得最大的性能和稳定性. 
</code></pre><h2 id=限制apache并发连接数>限制Apache并发连接数<a hidden class=anchor aria-hidden=true href=#限制apache并发连接数>#</a></h2><p>我们知道当网站以http方式提供软件下载时,若是每个用户都开启多个线程并没有带宽的限制,将很快达到http的最大连接数或者造成网络阻塞,使得网站的许多正常服务都无法运行.下面我们添加mod_limitipconn模块,来控制http的并发连接数.</p><pre><code># wget http://dominia.org/djao/limit/mod_limitipconn-0.22.tar.gz
# tar zxvf mod_limitipconn-0.22.tar.gz
# cd mod_limitipconn-0.22
# /usr/local/apache/bin/ apxs -c -i -a mod_limitipconn.c
# 编译好后会自动把mod_rewrite.so拷贝到/usr/local/apache/modules下,并修改你的httpd.conf文件.
# vi /usr/local/apache/conf/httpd.conf
# 在最后一行加入
#所限制的目录所在,此处表示主机的根目录MaxConnPerIP 2
#所限制的每个IP并发连接数为2个

# 保存退出.
# /usr/local/apache/bin/apachectl start
</code></pre><p>我们刚才已经限制了IP并发数,但如果对方把链接盗链到别的页面,我们刚才做的就毫无意义了,因为他完全可以通过蚂蚁或快车进行下载.所以就这种情况,我们要引用mod_rewrite.so模块.这样,当他盗链了文件,通过mod_rewrite.so模块把页面引到了一个事先我们制定好的错误页面里,这样就防止了盗链。</p><pre><code># /usr/local/apache/bin/apxs -c -i -a /opt/httpd-2.0.52/modules/mappers/mod_rewrite.c
# 编译好后会自动把mod_rewrite.so拷贝到/usr/local/apache/modules下,并修改你的httpd.conf文件.

# vi /usr/local/apache/conf/httpd.conf

RewriteEngine onRewriteCond %{HTTP_REFERER} !
^http://www.squall.cn/.*$ [NC]RewriteCond %{HTTP_REFERER} !
^http://www.squall.cn$ [NC]RewriteCond %{HTTP_REFERER} !
^http://squall.cn/.*$ [NC]RewriteCond %{HTTP_REFERER} !
^http://squall.cn$ [NC]RewriteRule .*\\.
(jpg|gif|png|bmp|tar|gz|rar|zip|exe)$
http://www.squall.cn/error.htm [R,NC]
</code></pre><p>到此,我们就对Apache做了一次全面优化,性能比原来明显地有了很大的提高.这次实施过程到此也就圆满的结束了.相信大家通过读完我的这篇文章后,对Apache优化也有了一些心得,相信你在工作中也会处理好突发事件。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://phpgao.github.io/tags/apache/>apache</a></li></ul><nav class=paginav><a class=prev href=https://phpgao.github.io/regex_fast_reference.html><span class=title>« Prev Page</span><br><span>常用正则表达式速查</span></a>
<a class=next href=https://phpgao.github.io/10_css_mnemonics.html><span class=title>Next Page »</span><br><span>CSS十条速记口诀</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://phpgao.github.io/>老高的技术博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>