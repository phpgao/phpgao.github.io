<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>我们为什么使用框架 | 老高的技术博客</title><meta name=keywords content="framework"><meta name=description content="这篇文章于昨日早在215路早读时看到，写的很不错！可以作为学习框架或者写自己的框架之前的读物。
ps.文章中提到了一个名词——控制反转。这个词可能经常会考倒刚入门程序员。控制反转其实其实是一种外包的思想，将总做交给各个领域的&rsquo;专家&rsquo;去做，而你只负责如何调度他们的工作。明确的分工会给系统带来很多维护上的便利。这个概念常常和依赖注入同时出现，而什么是依赖注入呢？其实他是控制反转的一个实现方式。
如果你对框架这个概念还不是很理解，那么还可以参考一下老高的系列文章THINKPHP框架解析，老高带你深入框架内部，去看看框架到底做了什么，和为什么这么做。希望这篇转帖和老高的文章能够帮助你深入理解框架的作用。"><meta name=author content="Me"><link rel=canonical href=https://phpgao.github.io/framework_faq.html><link crossorigin=anonymous href=/assets/css/stylesheet.min.1a6ee89730e13a801d0f34e0cb5b98e96cf8c65b80500638bd599fc224ed8442.css integrity="sha256-Gm7olzDhOoAdDzTgy1uY6Wz4xluAUAY4vVmfwiTthEI=" rel="preload stylesheet" as=style><link rel=preload href="https://cdn.v2ex.com/gravatar/2b66f45a3e2f41db6522381006bfaea1?s=192" as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://phpgao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://phpgao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://phpgao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://phpgao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://phpgao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-39288145-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="我们为什么使用框架"><meta property="og:description" content="这篇文章于昨日早在215路早读时看到，写的很不错！可以作为学习框架或者写自己的框架之前的读物。
ps.文章中提到了一个名词——控制反转。这个词可能经常会考倒刚入门程序员。控制反转其实其实是一种外包的思想，将总做交给各个领域的&rsquo;专家&rsquo;去做，而你只负责如何调度他们的工作。明确的分工会给系统带来很多维护上的便利。这个概念常常和依赖注入同时出现，而什么是依赖注入呢？其实他是控制反转的一个实现方式。
如果你对框架这个概念还不是很理解，那么还可以参考一下老高的系列文章THINKPHP框架解析，老高带你深入框架内部，去看看框架到底做了什么，和为什么这么做。希望这篇转帖和老高的文章能够帮助你深入理解框架的作用。"><meta property="og:type" content="article"><meta property="og:url" content="https://phpgao.github.io/framework_faq.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-10-10T13:34:00+00:00"><meta property="article:modified_time" content="2014-10-10T13:34:00+00:00"><meta property="og:site_name" content="老高的技术博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="我们为什么使用框架"><meta name=twitter:description content="这篇文章于昨日早在215路早读时看到，写的很不错！可以作为学习框架或者写自己的框架之前的读物。
ps.文章中提到了一个名词——控制反转。这个词可能经常会考倒刚入门程序员。控制反转其实其实是一种外包的思想，将总做交给各个领域的&rsquo;专家&rsquo;去做，而你只负责如何调度他们的工作。明确的分工会给系统带来很多维护上的便利。这个概念常常和依赖注入同时出现，而什么是依赖注入呢？其实他是控制反转的一个实现方式。
如果你对框架这个概念还不是很理解，那么还可以参考一下老高的系列文章THINKPHP框架解析，老高带你深入框架内部，去看看框架到底做了什么，和为什么这么做。希望这篇转帖和老高的文章能够帮助你深入理解框架的作用。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://phpgao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"我们为什么使用框架","item":"https://phpgao.github.io/framework_faq.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"我们为什么使用框架","name":"我们为什么使用框架","description":"这篇文章于昨日早在215路早读时看到，写的很不错！可以作为学习框架或者写自己的框架之前的读物。\nps.文章中提到了一个名词——控制反转。这个词可能经常会考倒刚入门程序员。控制反转其实其实是一种外包的思想，将总做交给各个领域的\u0026rsquo;专家\u0026rsquo;去做，而你只负责如何调度他们的工作。明确的分工会给系统带来很多维护上的便利。这个概念常常和依赖注入同时出现，而什么是依赖注入呢？其实他是控制反转的一个实现方式。\n如果你对框架这个概念还不是很理解，那么还可以参考一下老高的系列文章THINKPHP框架解析，老高带你深入框架内部，去看看框架到底做了什么，和为什么这么做。希望这篇转帖和老高的文章能够帮助你深入理解框架的作用。\n","keywords":["framework"],"articleBody":"这篇文章于昨日早在215路早读时看到，写的很不错！可以作为学习框架或者写自己的框架之前的读物。\nps.文章中提到了一个名词——控制反转。这个词可能经常会考倒刚入门程序员。控制反转其实其实是一种外包的思想，将总做交给各个领域的’专家’去做，而你只负责如何调度他们的工作。明确的分工会给系统带来很多维护上的便利。这个概念常常和依赖注入同时出现，而什么是依赖注入呢？其实他是控制反转的一个实现方式。\n如果你对框架这个概念还不是很理解，那么还可以参考一下老高的系列文章THINKPHP框架解析，老高带你深入框架内部，去看看框架到底做了什么，和为什么这么做。希望这篇转帖和老高的文章能够帮助你深入理解框架的作用。\n原文链接\n作者：\nntopass，Java编程爱好者\n以下：\n我来谈一谈自己的理解吧。\n从DRY原则开始 Don’t Repeat Yourself，不要重复你的代码。\n如果有一些代码我们重复了两次，我们总是要把它们提取出来变成一个方法。 渐渐的我们有了一批方法，我们把它整合成工具类。如DBUtils，我相信很多人都写过。 相应的，工具类还可以整合成类库。类库一般以JAR的形式部署，更容易使用。\n以上仍然是自己从底层一点一点的做起，如果有现成的类库可以使用不更好吗？ 不要重复造“轮子”，总会有专业造“轮子”的，我们只需要直接使用已有的类库即可。 如Apache Commons项目，这简直成了Java标准库的标准扩展了。\n框架也是一样 框架，是为了解决某个特定领域的问题而诞生的。 框架，是为了我们不必总是写相同代码而诞生的。 框架，是为了让我们专注于业务逻辑而诞生的。\n框架把我们程序设计中不变的部分抽取出来，让我们专注于与业务有关的代码。 而著名的SSH三大框架就是为了解决Java Web开发中的问题。\nJ2EE的发展 本来网站都是一个个静态HTML的，但很快我们就不满足于这样了。动态网页应运而生。\n一开始是Servlet。其代码类似于下面这样。 主要是Java代码，然后用out一点一点输出HTML代码。 当然代码无比丑陋，且美工人员几乎不能理解这样的代码。\nout.write(\"\\r\\n\");\rout.write(\"\\r\\n\");\rout.write(\"\\r\\n\");\rout.write(\"首页\\r\\n\");\rout.write(\"\\r\\n\");\rout.write(\"\\r\\n\");\rout.write(\"Hello, \" + new Date().toLocalString\rout.write(\"\\r\\n\");\rout.write(\"\\r\\n\");\r 所以，很快JSP应运而生。其代码类似于下面这样。 JSP很像是正常的HTML代码中，藏了一些Java代码。 就这样Java Web技术疯狂发展了。\n\r\r首页\r\r\r0) {\rout.println(\"Welcome, \" + user + \"! You are logged in.\");\r}\r%\r\r\r 随着实际Web应用的使用越来越广泛，Web应用的规模也越来越大，开发人员发现动态Web应用的维护成本也越来越大，即使只需要修改该页面的一个简单按钮文本，或者一段静态的文本内容，也不得不打开混杂的动态脚本的页面源文件进行修改——这是一种很大的风险，完全有可能引入新的错误。\nMVC模式的诞生 这时候，人们意识到：单纯使用JSP页面充当过多角色是相当失败的选择，这对于后期的维护相当不利，慢慢地开发人员开始在Web开发中使用MVC模式。\nJava阵营慢慢的发展出了适合Java Web开的的MVC模式。（看下图） 使用JSP作为视图，Servlet作为控制器，JavaBean作为模型。 通过合理的分层，使得Java程序员更能驾驭大型网站的开发。\n使用MVC模式有一个问题，Servlet中获取到的数据如何传递到视图层呢？\n//一般采取这种办法\r//在Servlet中将结果设置到request对象当中。\rrequest.setAttribute(\"result\", result);\r//在JSP中通过request对象来获取。\r 可是JSP既然是视图层，如果嵌入太多JAVA代码的话，对于美工的工作相当不利。 一般来说视图层是不允许使用来嵌入JAVA代码的。 可是视图层也确实需要负责进行一些逻辑判断，来动态输出页面。\n当然，Java提供了一个办法，使用“自定义标签”，和“EL表达式”。\n\r\r序号\r姓名\r性别\r年龄\r电话\r\r\r${item.id}\r${item.name}\r${item.sex}\r${item.age}\r${item.phone}\r\r\r\r 视图层的问题看起来不太大，现在来看看控制层。\n//首先，你需要在Web.xml中进行配置\r\rLoginServlet\rcom.tee.servlet.LoginServlet\r\r\rLoginServlet\r/Login\r\r//然后，需要编写一个继承自HttpServlet类的Servlet。\rpackage com.tee.servlet;\rimport javax.servlet.ServletException;\rimport javax.servlet.http.HttpServlet;\rimport javax.servlet.http.HttpServletRequest;\rimport javax.servlet.http.HttpServletResponse;\rpublic class RegisterServlet extends HttpServlet {\rprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\rString username = request.getParameter(\"username\");\rString password = request.getParameter(\"password\");\rif (UserDao.validate(username, password)) {\rrequest.getSession.setAttribute(\"user\", username);\rresponse.setContentType(\"text/html; charset=utf-8\");\rresponse.sendRedirect(\"/index.jsp\");\r} else {\rServletContext sc = getServletContext();\rRequestDispatcher rd = sc.getRequestDispatcher(\"/login.jsp\");\rrequest.setAttribute(\"errMsg\", \"login failure\");\rrd.forward(request, response);\r}\r}\rprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {\rdoGet(request,response);\r}\r}\r 这样一来，首先Web.xml会越来越大，越来越难以维护。 且修改Web.xml的风险很大，只要一个错误，整个网站都有可能无法访问。\n上面的例子没有进行传入参数的检验，如是否为空，是否有是规定长度，是否是规定的字符。也没有涉及到参数转换，如转换成Date类型，转换成int类型。一旦发生错误又该如何传递给前端，前端又该如何接受错误信息，如何展示出来。\n因为Servlet必须继承自HttpServlet，且内部与Servlet Api高度耦合，不但难以测试，而且难以重用。更不要说我们总是需要书写大量与业务逻辑无关的代码。\nMVC框架的诞生 同样的代码写两次就是罪过，所以我们需要什么东西来让我们解放出来。 很快人们就发展出了一套MVC框架，特别是适合于Java Web的MVC框架。\nMVC框架能帮我们做什么？ 这里引用“四刘”的回答： 框架和普通库的几点区别里，我认为最重要的一点是控制反转。 框架规定了开发者写哪些代码／不写哪些代码，怎么写代码——这就是框架主要解决的问题。 MVC框架实现了MVC模式。什么意思？ 意思是只要你根据框架的要求填充代码，你就能够很简单的实现MVC模式。\n谁来响应用户请求？框架可能告诉你，Action就是用来响应用户请求的。 不用再继承HttpServlet，代码中也可以完全脱离Servlet Api。复用度高，可单元测试。\n谁负责生成响应界面？框架可能告诉你，可以用一个JSP文件来生成界面。 也可以用其他视图技术，JfreeChart，FreeMarke，JasperReports，JSF，Tiles，Vlocit等。\n如何将网址匹配到Action？框架可能告诉你，在XML文件中配置，且可以分模块配置。 如何确定该返回那个JSP？框架可能告诉你，在XML文件中配置好了，Action返回SUCCESS，INPUT，LOGIN等等即可。\nAction如何接受参数？框架可能告诉你，写个Setter方法，就可以接受相应参数。不用再从request获取，且类型可自动转换。根据配置处理编码问题。 Action如何与视图交互？框架可能告诉你，Action自动与视图绑定，在Action写一个Getter方法，试图层就可以用自定义标签获取其值。\n输入校验如何进行？写个validate方法，有错误就调用addActionError方法，自动返回配置中，INPUT指定的页面，页面用标签就可以自动输出错误信息。 也可以使用addFieldError方法添加特定field的错误，使用输出特定field的错误信息。 甚至使用方法生成的输入框，可以自动显示该字段的错误信息。\n使用框架的必要性 需要指出的是，只有在相当规模的程序中应用这些框架才能体会到好处。 如果你的网站、程序很小，那么没有必要杀鸡用牛刀。\n需要学习框架吗 那么新手需要学习框架吗？我不建议新手一上来就学习框架。 就好像新手不要一上来就使用IDE，一定要用JDK自己编几回代码后才能知道IDE帮我们做了什么。\n那么新手也不要一开始就使用框架，否则你就不知道框架帮你做了什么，而这并不利于程序员的成长。在学习阶段，先试试不用框架我该如何做，然后会更明白框架的意义。\n如果你自己不经历过大型程序的开发，很难理解IoC框架存在的必要性。 我直接new一个不就行了吗？AOP有什么用？声明式事务有什么好处？\n如果你不懂AOP，不懂编程式事务，不懂ThreadLocal，那你就很难理解基于注解的声明式事务，你只会感觉到他很神奇，你就很难理解为什么要使用sf.getCurrentSession()，而不是sf.openSession()。很难理解Hibernate经常遇到的懒加载异常。\n最后再谈一谈 框架 和 类库的不同。 请允许我再次引用“四刘”的回答： 框架和普通库的几点区别里，我认为最重要的一点是控制反转。 框架规定了开发者写哪些代码／不写哪些代码，怎么写代码——这就是框架主要解决的问题。 先说说控制反转 一般程序，程序该如何运转，是由我们程序员全盘掌握的。\n程序的一切资源的初始化、资源的销毁、资源的定位查找都是我们自己写代码实现的。 程序的一且流程都可以从我们的代码中依次找到，只要你顺着我的程序主入口开始查找。\n但是应用框架后的控制权已经交给了框架。如Java Web框架，我们一般都要在Web.xml文件中配置框架的核心控制器、拦截器。这就是把控制权交出的过程。\n就好比说原先你是老板，一切工作都亲力亲为，一切问题都是先提交到你这，然后你分配出去。 有了框架之后，就好比是找了个总经理，一切问题他先处理，需要你处理的才来请示你。 就算是要请示你，也先把材料都整理过了，以你最舒服的形式提交给你。\n再说说类库和框架的不同 类库就好像是负面清单，类库里实现的代码你就不用写了，程序需要的其他代码你来写。 关键就是其他代码有多少？类库没告诉你，需要你程序员心理有数。\n框架就好像是正面清单，框架直接告诉你，你只需要把这些代码写完，程序就可以正常运行了。 框架就好像建筑里的框架结构一样，有了框架，这个建筑就完成了大半，剩下的就是装修问题了。\n","wordCount":"301","inLanguage":"en","datePublished":"2014-10-10T13:34:00Z","dateModified":"2014-10-10T13:34:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://phpgao.github.io/framework_faq.html"},"publisher":{"@type":"Organization","name":"老高的技术博客","logo":{"@type":"ImageObject","url":"https://phpgao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://phpgao.github.io/ accesskey=h title="老高的博客 (Alt + H)">老高的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://phpgao.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://phpgao.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://blog.phpgao.com title="old blog"><span>old blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://phpgao.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://phpgao.github.io/posts/>Posts</a></div><h1 class=post-title>我们为什么使用框架</h1><div class=post-meta>October 10, 2014&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2014-10-10_framework_faq.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>这篇文章于昨日早在215路早读时看到，写的很不错！可以作为学习框架或者写自己的框架之前的读物。</p><p>ps.文章中提到了一个名词——<strong>控制反转</strong>。这个词可能经常会考倒刚入门程序员。控制反转其实其实是一种外包的思想，将总做交给各个领域的&rsquo;专家&rsquo;去做，而你只负责如何调度他们的工作。明确的分工会给系统带来很多维护上的便利。这个概念常常和<strong>依赖注入</strong>同时出现，而什么是依赖注入呢？其实他是控制反转的一个实现方式。</p><p>如果你对框架这个概念还不是很理解，那么还可以参考一下老高的系列文章<a href=https://blog.phpgao.com/thinkphp_init.html>THINKPHP框架解析</a>，老高带你深入框架内部，去看看框架到底做了什么，和为什么这么做。希望这篇转帖和老高的文章能够帮助你深入理解框架的作用。</p><p><a href=http://www.zhihu.com/question/25654738/answer/31302541>原文链接</a></p><p>作者：</p><p><a href=http://www.zhihu.com/people/intopass>ntopass，Java编程爱好者</a></p><p>以下：</p><p>我来谈一谈自己的理解吧。</p><h2 id=从dry原则开始>从DRY原则开始<a hidden class=anchor aria-hidden=true href=#从dry原则开始>#</a></h2><p>Don&rsquo;t Repeat Yourself，不要重复你的代码。</p><p>如果有一些代码我们重复了两次，我们总是要把它们提取出来变成一个方法。
渐渐的我们有了一批方法，我们把它整合成工具类。如DBUtils，我相信很多人都写过。
相应的，工具类还可以整合成类库。类库一般以JAR的形式部署，更容易使用。</p><p>以上仍然是自己从底层一点一点的做起，如果有现成的类库可以使用不更好吗？
不要重复造“轮子”，总会有专业造“轮子”的，我们只需要直接使用已有的类库即可。
如Apache Commons项目，这简直成了Java标准库的标准扩展了。</p><p>框架也是一样
框架，是为了解决某个特定领域的问题而诞生的。
框架，是为了我们不必总是写相同代码而诞生的。
框架，是为了让我们专注于业务逻辑而诞生的。</p><p>框架把我们程序设计中不变的部分抽取出来，让我们专注于与业务有关的代码。
而著名的SSH三大框架就是为了解决Java Web开发中的问题。</p><h2 id=j2ee的发展>J2EE的发展<a hidden class=anchor aria-hidden=true href=#j2ee的发展>#</a></h2><p>本来网站都是一个个静态HTML的，但很快我们就不满足于这样了。动态网页应运而生。</p><p>一开始是Servlet。其代码类似于下面这样。
主要是Java代码，然后用out一点一点输出HTML代码。
当然代码无比丑陋，且美工人员几乎不能理解这样的代码。</p><pre><code>out.write(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;\r\n&quot;);
out.write(&quot;&lt;html&gt;\r\n&quot;);
out.write(&quot;&lt;head&gt;\r\n&quot;);
out.write(&quot;&lt;title&gt;首页&lt;/title&gt;\r\n&quot;);
out.write(&quot;&lt;/head&gt;\r\n&quot;);
out.write(&quot;&lt;body&gt;\r\n&quot;);
out.write(&quot;Hello, &quot; + new Date().toLocalString
out.write(&quot;&lt;/body&gt;\r\n&quot;);
out.write(&quot;&lt;/html&gt;\r\n&quot;);
</code></pre><p>所以，很快JSP应运而生。其代码类似于下面这样。
JSP很像是正常的HTML代码中，藏了一些Java代码。
就这样Java Web技术疯狂发展了。</p><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

	&lt;ss:a label=&quot;首页&quot; href=&quot;/index.jsp&quot; /&gt;
	&lt;ss:a label=&quot;登入&quot; href=&quot;/login.jsp&quot; /&gt;
	&lt;ss:a label=&quot;注册&quot; href=&quot;/register.jsp&quot; /&gt;
	&lt;ss:a label=&quot;登出&quot; href=&quot;/logout.do&quot; /&gt;
	&lt;hr /&gt;

	&lt;jsp:include page=&quot;/include/jsp/datetime.jsp&quot; /&gt;
	&lt;%
        String user = (String) session.getAttribute(&quot;user&quot;);
        if (user != null &amp;&amp; user.length() &gt; 0) {
            out.println(&quot;Welcome, &lt;b&gt;&quot; + user + &quot;&lt;/b&gt;! You are logged in.&quot;);
        }
	%&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>随着实际Web应用的使用越来越广泛，Web应用的规模也越来越大，开发人员发现动态Web应用的维护成本也越来越大，即使只需要修改该页面的一个简单按钮文本，或者一段静态的文本内容，也不得不打开混杂的动态脚本的页面源文件进行修改——这是一种很大的风险，完全有可能引入新的错误。</p><h2 id=mvc模式的诞生>MVC模式的诞生<a hidden class=anchor aria-hidden=true href=#mvc模式的诞生>#</a></h2><p>这时候，人们意识到：单纯使用JSP页面充当过多角色是相当失败的选择，这对于后期的维护相当不利，慢慢地开发人员开始在Web开发中使用MVC模式。</p><p>Java阵营慢慢的发展出了适合Java Web开的的MVC模式。（看下图）
使用JSP作为视图，Servlet作为控制器，JavaBean作为模型。
通过合理的分层，使得Java程序员更能驾驭大型网站的开发。</p><p><img loading=lazy src=http://pic3.zhimg.com/a2ae24d5a1bfc325e6c0259d0dc39177_b.jpg alt=MVC图解></p><p>使用MVC模式有一个问题，Servlet中获取到的数据如何传递到视图层呢？</p><pre><code>//一般采取这种办法
//在Servlet中将结果设置到request对象当中。
request.setAttribute(&quot;result&quot;, result);

//在JSP中通过request对象来获取。
&lt;% Object result = request.getAttribute(&quot;result&quot;); %&gt;
</code></pre><p>可是JSP既然是视图层，如果嵌入太多JAVA代码的话，对于美工的工作相当不利。
一般来说视图层是不允许使用&lt;% %>来嵌入JAVA代码的。
可是视图层也确实需要负责进行一些逻辑判断，来动态输出页面。</p><p>当然，Java提供了一个办法，使用“自定义标签”，和“EL表达式”。</p><pre><code>&lt;table&gt;
    &lt;th&gt;
      &lt;td&gt;序号&lt;/td&gt;
      &lt;td&gt;姓名&lt;/td&gt;
      &lt;td&gt;性别&lt;/td&gt;
      &lt;td&gt;年龄&lt;/td&gt;
      &lt;td&gt;电话&lt;/td&gt;
    &lt;/th&gt;
  &lt;c:forEach var=&quot;item&quot; items=&quot;${request.list}&quot;&gt;
    &lt;tr&gt;
      &lt;td&gt;${item.id}&lt;/td&gt;
      &lt;td&gt;${item.name}&lt;/td&gt;
      &lt;td&gt;${item.sex}&lt;/td&gt;
      &lt;td&gt;${item.age}&lt;/td&gt;
      &lt;td&gt;${item.phone}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/c:forEach&gt;
&lt;/table&gt;
</code></pre><p>视图层的问题看起来不太大，现在来看看控制层。</p><pre><code>//首先，你需要在Web.xml中进行配置
&lt;servlet&gt;
  &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.tee.servlet.LoginServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/Login&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

//然后，需要编写一个继承自HttpServlet类的Servlet。
package com.tee.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class RegisterServlet extends HttpServlet {

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        String username = request.getParameter(&quot;username&quot;);
        String password = request.getParameter(&quot;password&quot;);
        if (UserDao.validate(username, password)) {
            request.getSession.setAttribute(&quot;user&quot;, username);
            response.setContentType(&quot;text/html; charset=utf-8&quot;);
            response.sendRedirect(&quot;/index.jsp&quot;);
        } else {
            ServletContext sc = getServletContext();
            RequestDispatcher rd = sc.getRequestDispatcher(&quot;/login.jsp&quot;);
            request.setAttribute(&quot;errMsg&quot;, &quot;login failure&quot;);
            rd.forward(request, response);
        }
	}
	
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException {
        doGet(request,response);
	}
}
</code></pre><p>这样一来，首先Web.xml会越来越大，越来越难以维护。
且修改Web.xml的风险很大，只要一个错误，整个网站都有可能无法访问。</p><p>上面的例子没有进行传入参数的检验，如是否为空，是否有是规定长度，是否是规定的字符。也没有涉及到参数转换，如转换成Date类型，转换成int类型。一旦发生错误又该如何传递给前端，前端又该如何接受错误信息，如何展示出来。</p><p>因为Servlet必须继承自HttpServlet，且内部与Servlet Api高度耦合，不但难以测试，而且难以重用。更不要说我们总是需要书写大量与业务逻辑无关的代码。</p><h2 id=mvc框架的诞生>MVC框架的诞生<a hidden class=anchor aria-hidden=true href=#mvc框架的诞生>#</a></h2><p>同样的代码写两次就是罪过，所以我们需要什么东西来让我们解放出来。
很快人们就发展出了一套MVC框架，特别是适合于Java Web的MVC框架。</p><h2 id=mvc框架能帮我们做什么>MVC框架能帮我们做什么？<a hidden class=anchor aria-hidden=true href=#mvc框架能帮我们做什么>#</a></h2><p>这里引用“四刘”的回答：
框架和普通库的几点区别里，我认为最重要的一点是控制反转。
框架规定了开发者写哪些代码／不写哪些代码，怎么写代码——这就是框架主要解决的问题。
MVC框架实现了MVC模式。什么意思？
意思是只要你根据框架的要求填充代码，你就能够很简单的实现MVC模式。</p><p>谁来响应用户请求？框架可能告诉你，Action就是用来响应用户请求的。
不用再继承HttpServlet，代码中也可以完全脱离Servlet Api。复用度高，可单元测试。</p><p>谁负责生成响应界面？框架可能告诉你，可以用一个JSP文件来生成界面。
也可以用其他视图技术，JfreeChart，FreeMarke，JasperReports，JSF，Tiles，Vlocit等。</p><p>如何将网址匹配到Action？框架可能告诉你，在XML文件中配置，且可以分模块配置。
如何确定该返回那个JSP？框架可能告诉你，在XML文件中配置好了，Action返回SUCCESS，INPUT，LOGIN等等即可。</p><p>Action如何接受参数？框架可能告诉你，写个Setter方法，就可以接受相应参数。不用再从request获取，且类型可自动转换。根据配置处理编码问题。
Action如何与视图交互？框架可能告诉你，Action自动与视图绑定，在Action写一个Getter方法，试图层就可以用自定义标签获取其值。</p><p>输入校验如何进行？写个validate方法，有错误就调用addActionError方法，自动返回配置中，INPUT指定的页面，页面用&lt;s:actionerrors/>标签就可以自动输出错误信息。
也可以使用addFieldError方法添加特定field的错误，使用&lt;s:fielderror/>输出特定field的错误信息。
甚至使用&lt;s:textfield>方法生成的输入框，可以自动显示该字段的错误信息。</p><h2 id=使用框架的必要性>使用框架的必要性<a hidden class=anchor aria-hidden=true href=#使用框架的必要性>#</a></h2><p>需要指出的是，只有在相当规模的程序中应用这些框架才能体会到好处。
如果你的网站、程序很小，那么没有必要杀鸡用牛刀。</p><h2 id=需要学习框架吗>需要学习框架吗<a hidden class=anchor aria-hidden=true href=#需要学习框架吗>#</a></h2><p>那么新手需要学习框架吗？我不建议新手一上来就学习框架。
就好像新手不要一上来就使用IDE，一定要用JDK自己编几回代码后才能知道IDE帮我们做了什么。</p><p>那么新手也不要一开始就使用框架，否则你就不知道框架帮你做了什么，而这并不利于程序员的成长。在学习阶段，先试试不用框架我该如何做，然后会更明白框架的意义。</p><p>如果你自己不经历过大型程序的开发，很难理解IoC框架存在的必要性。
我直接new一个不就行了吗？AOP有什么用？声明式事务有什么好处？</p><p>如果你不懂AOP，不懂编程式事务，不懂ThreadLocal，那你就很难理解基于注解的声明式事务，你只会感觉到他很神奇，你就很难理解为什么要使用sf.getCurrentSession()，而不是sf.openSession()。很难理解Hibernate经常遇到的懒加载异常。</p><p>最后再谈一谈 框架 和 类库的不同。
请允许我再次引用“四刘”的回答：
框架和普通库的几点区别里，我认为最重要的一点是控制反转。
框架规定了开发者写哪些代码／不写哪些代码，怎么写代码——这就是框架主要解决的问题。
先说说控制反转
一般程序，程序该如何运转，是由我们程序员全盘掌握的。</p><p>程序的一切资源的初始化、资源的销毁、资源的定位查找都是我们自己写代码实现的。
程序的一且流程都可以从我们的代码中依次找到，只要你顺着我的程序主入口开始查找。</p><p>但是应用框架后的控制权已经交给了框架。如Java Web框架，我们一般都要在Web.xml文件中配置框架的核心控制器、拦截器。这就是把控制权交出的过程。</p><p>就好比说原先你是老板，一切工作都亲力亲为，一切问题都是先提交到你这，然后你分配出去。
有了框架之后，就好比是找了个总经理，一切问题他先处理，需要你处理的才来请示你。
就算是要请示你，也先把材料都整理过了，以你最舒服的形式提交给你。</p><p>再说说类库和框架的不同
类库就好像是负面清单，类库里实现的代码你就不用写了，程序需要的其他代码你来写。
关键就是其他代码有多少？类库没告诉你，需要你程序员心理有数。</p><p>框架就好像是正面清单，框架直接告诉你，你只需要把这些代码写完，程序就可以正常运行了。
框架就好像建筑里的框架结构一样，有了框架，这个建筑就完成了大半，剩下的就是装修问题了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://phpgao.github.io/tags/framework/>framework</a></li></ul><nav class=paginav><a class=prev href=https://phpgao.github.io/virtual_machine_record.html><span class=title>« Prev Page</span><br><span>新装虚拟机记录一下</span></a>
<a class=next href=https://phpgao.github.io/run_nginx_as_service.html><span class=title>Next Page »</span><br><span>将nginx配置为服务</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://phpgao.github.io/>老高的技术博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>