<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang简介 | 老高的技术博客</title><meta name=keywords content="golang"><meta name=description content="Golang简介"><meta name=author content="Me"><link rel=canonical href=https://phpgao.github.io/golang.html><link crossorigin=anonymous href=/assets/css/stylesheet.min.1a6ee89730e13a801d0f34e0cb5b98e96cf8c65b80500638bd599fc224ed8442.css integrity="sha256-Gm7olzDhOoAdDzTgy1uY6Wz4xluAUAY4vVmfwiTthEI=" rel="preload stylesheet" as=style><link rel=preload href="https://cdn.v2ex.com/gravatar/2b66f45a3e2f41db6522381006bfaea1?s=192" as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://phpgao.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://phpgao.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://phpgao.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://phpgao.github.io/apple-touch-icon.png><link rel=mask-icon href=https://phpgao.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-39288145-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="Golang简介"><meta property="og:description" content="Golang简介"><meta property="og:type" content="article"><meta property="og:url" content="https://phpgao.github.io/golang.html"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-06-23T05:13:00+00:00"><meta property="article:modified_time" content="2017-06-23T05:13:00+00:00"><meta property="og:site_name" content="老高的技术博客"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang简介"><meta name=twitter:description content="Golang简介"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://phpgao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Golang简介","item":"https://phpgao.github.io/golang.html"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang简介","name":"Golang简介","description":"Golang简介","keywords":["golang"],"articleBody":"Golang简介  Why Golang?  我发现我花了四年时间锤炼自己用 C 语言构建系统的能力，试图找到一个规范，可以更好的编写软件。结果发现只是对 Go 的模仿。缺乏语言层面的支持，只能是一个拙劣的模仿。 — 吴云洋(云风的 BLOG)\n  特点  并行 快速 UTF-8 跨平台   配置运行环境 下载安装 官网下载地址 https://golang.org/dl/\n下载文件并执行安装，Linux系统只需要解压即可！\nDocker–Golang\n tips 命令行godoc -http=:8081 可以查看离线文档\n 配置 指定GOPATH为将要工作的目录，然后将bin添加到PATH中，输入命令go env查看\nGOARCH=\"amd64\" ---架构 GOBIN=\"\" ---编译好的文件 GOEXE=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOOS=\"darwin\" --系统 GOPATH=\"/Users/gaozhimin/work\" --工作目录 GORACE=\"\" GOROOT=\"/usr/local/go\" --go的安装目录 GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\" CC=\"clang\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/qy/y1gwdk9x425f4nn60278ncp00000gn/T/go-build689949734=/tmp/go-build -gno-record-gcc-switches -fno-common\" CXX=\"clang++\" CGO_ENABLED=\"1\" 编辑器 推荐使用\n vscode sublime3 atom liteide   基本语法 HELLO_WORLD // 一个文件夹内只能有一个包名 package main import \"fmt\" func main() { // P在⬇️此处大写，注意 \tfmt.Println(\"Hello world!\") // 普通字符使用双引号 } Golang的双引号和反引号都可用于表示一个常量字符串，不同在于：\n 双引号用来创建可解析的字符串字面量(支持转义，但不能用来引用多行) 反引号用来创建原生的字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式  变量声明  类型在变量的后面\n 例子 var a int var b bool // := 等价于 var 后赋值 c := 5 var ( e int f bool ) g := `Linkin Park` const x = 42 const ( y = 1 b = \"\" ) 基本类型  int，Runes（注：Rune 是int 的别名） int8 ,int16 ,int32 ,int64 byte ,uint8 ,uint16 ,uint32 ,uint64 （注：byte是uint8 的别名） float32 ，float64 (没有float 类型) bool string complex128，complex64   保留关键字 break case chan const continue default func defer go else goto fallthrough if for import interface map package range return select struct switch type var\n对比PHP  控制结构 // if if err := Chmod(0664); err != nil { // 注意err的作用于 fmt.Printf(err) return err } // for sum := 0 for i := 0; i  复合类型 array、slices 和 map\narray // 定长 var arr [10]int // 长度不同类型不同 var a [10]int var b [11]int a = b //报错 // 传值不传址 slice // 长度可以改变 sl := make([]int, 10) // 传地址 s1 := []int{1, 2, 3} s2 := s1 fmt.Println(s2) s1[0] = 0 fmt.Println(s2) // [1 2 3] // [0 2 3] s3 := append(s3, 4) fmt.Println(s3) map ≈ python.map\nnewMap := map[int]string{ 0: \"Sun\", 1: \"Mon\", 2: \"Tue\", 3: \"Wed\", 4: \"Thu\", 5: \"Fri\", 6: \"Sat\", } // 查找键值是否存在 if v, ok := newMap[7]; ok { fmt.Println(v) } else { fmt.Println(\"Key Not Found\") } // Key Not Found delete(newMap, 5) fmt.Println(newMap)  函数 作用域 package main var a = 6 func main() { p() q() p() } func p() { println(a) } func q() { a := 5 // a = 5 \tprintln(a) } 返回格式 // 函数参数 ip，类型为string // 函数返回，conn和error func connect(ip string) (conn *conn, err error){ ... ... return } func connect(ip string) (*conn, error){ conn := xxxx err := xxx return conn, err } // 接参数 con, err = connect(\"127.0.0.1\") if err != nil{ panic(\"error\") } // 忽略参数 _, err = connect(\"127.0.0.1\") if err != nil{ panic(\"error\") } Defer func downloadFile(filepath string, url string) (err error) { // Create the file out, err := os.Create(filepath) if err != nil { return err } defer out.Close() // Get the data resp, err := http.Get(url) if err != nil { return err } defer resp.Body.Close() // Writer the body to file _, err = io.Copy(out, resp.Body) if err != nil { return err } return } 匿名函数 func main() { a := func() { fmt.Println(\"你好\") } a() } 回调 func main() { callback(\"callback\", print) } func print(s string) { fmt.Println(s) } func callback(s string, f func(string)) { f(s) } 恐慌和恢复 func main() { if throwsPanic(p) { fmt.Println(\"Panic Happened\") } } //可能出现恐慌 func p() { panic(\"failed\") } func throwsPanic(f func()) (b bool) { // defer在发生恐慌后能够执行，使用recover能捕捉到panic defer func() { if x := recover(); x != nil { b = true } }() f() return }  包  包是函数和数据的集合。用 package 关键字定义一个包。每个文件都必须以package开头！\n 包名 简洁明了，无下划线，无大小写混合，分隔符表示目录层级关系。\nimport的起点为\nimport ( \"io\" \"net/http\" \"os\" \"github.com/laogao/tools/lib\" ) net/http net/http 实现了 HTTP 请求、响应和 URL 的解析，并且提供了可扩展的 HTTP 服 务和基本的 HTTP 客户端。\nflag flag 包实现了命令行解析。\nos os 包提供了与平台无关的操作系统功能接口。其设计是 Unix 形式的。\nio 这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进 行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。\nfmt 包 fmt 实现了格式化的 I/O 函数，这与 C 的 printf 和 scanf 类似。格式化短语 派生于 C 。\n首字母大小写 名称以大写字母起始的是可导出(exported)的。\nfunc Add(a, b int) int { return a + b } func hide(){ xxxx } 工程目录 goWorkSpace // goWorkSpace为GOPATH目录 -- bin -- myApp1 // 编译生成 -- myApp2 // 编译生成 -- myApp3 // 编译生成 -- pkg -- src -- common 1 -- common 2 -- common utils ... -- myApp1 // project1 -- models -- controllers -- others -- main.go -- myApp2 // project2 -- models -- controllers -- others -- main.go -- myApp3 // project3 -- models -- controllers -- others -- main.go 获取第三方Go包 以https://github.com/go-sql-driver/mysql为例\ngo get github.com/go-sql-driver/mysql 指针和结构体 指针 func main() { var i int i = 1 var p *int p = \u0026i fmt.Printf(\"i=%d;p=%d;*p=%d\\n\", i, p, *p) *p = 2 fmt.Printf(\"i=%d;p=%d;*p=%d\\n\", i, p, *p) i = 3 fmt.Printf(\"i=%d;p=%d;*p=%d\\n\", i, p, *p) } 结构体 type foo int func main() { var a foo a = 1 fmt.Println(a) t1 := T{\"t1\"} fmt.Println(\"M1调用前：\", t1.Name) t1.M1() fmt.Println(\"M1调用后：\", t1.Name) fmt.Println(\"M2调用前：\", t1.Name) t1.M2() fmt.Println(\"M2调用后：\", t1.Name) } //想要使用结构体，可以在其类型上添加函数，也可以直接做参数传入函数中 type T struct { Name string } func (t T) M1() { t.Name = \"name1\" } func (t *T) M2() { t.Name = \"name2\" } 传值与传指针 当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。\n传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。\nGo语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）\n要访问指针 p 指向的结构体中某个元素 x，不需要显式地使用 * 运算，可以直接 p.x\n接口 package main import ( \"fmt\" ) type apple struct { } type pineapple struct { } func (a apple) eat() { fmt.Println(\"I'm an apple,I can be eaten\") } func (p *pineapple) eat() { fmt.Println(\"I'm a pineapple,I can be eaten\") } type eatable interface { eat() } func main() { apple := apple{} pineapple := new(pineapple) eat(apple) eat(pineapple) } func eat(sth eatable) { sth.eat() switch sth.(type) { case *pineapple: fmt.Println(\"Got a pineapple\") case apple: fmt.Println(\"Got a apple\") } } GC 设想你正在编写一个长期运行的后台服务，就让它是一个 web 应用服务或者某些更复杂的东西。通常来说，在整个运行周期都会需要分配内存。了解如何处理这些内存是必要的。\n通常，每 2 分钟会执行一次垃圾收集。如果某个片段持续 5 分钟都没有被使用，回收器会将其释放。\n因此，如果你认为内存使用会降低，那么 7 分钟之后再去确认吧。\n更多关于GC优化，可以浏览Go’s march to low-latency GC\n 并发 goroutine  goroutine不是线程、协程、进程等等，传递了不准确的含义。goroutine 有简单的模型:它是与其他 goroutine 并行执行的， 有着相同地址空间的函数。它是轻量的，仅比分配栈空间多一点点。 而初始时栈是很小的，所以它们也是廉价的，并且随着需要在堆空间上分 配(和释放)。\n 使用go关键字让一个函数以goroutine方式执行\nfunc echo(s string) { fmt.Println(s) } func main() { echo(\"hi\") go echo(\"hi\") // time.Sleep(5 * time.Second) } //猜测一下回打印出什么？为什么？ channel 如果不考虑go出去的函数，那么程序就会执行完毕并退出，goroutine也会随之停止，需要引入一个通讯机制，他就是channel。\nchannel ≈ pipe\n channel必须使用make关键字创建\n c1 := make(chan int) // channel可以有长度 c2 := make(chan string, 100) //channel的使用方法 c1 结合 在goroutine中我们把一个值写入chan，然后在主进程中尝试从chan中读取数据，如果此时chan中没有数据，程序会被阻塞，只到有值取出。\nvar c chan int func ready(w string, sec int) { time.Sleep(time.Duration(sec) * time.Second) fmt.Println(w, \"is ready!\") c 上面的例子是已经提前知道go出去的goroutine的个数才会这样写，当我们不知道个数的时候呢？\nfunc main() { c = make(chan int) go ready(\"Tea\", 2) go ready(\"Coffee\", 1) i := 0 //跳转标记L L: for { select { case 1 { break L } } } } 超时机制 func main() { c = make(chan string) timeout = make(chan bool) go ready(\"Tea\", 6) go ready(\"Coffee\", 1) go func() { time.Sleep(time.Second * 3) // 5 秒超时 timeout 读取文件 方法一 func main() { buf := make([]byte, 1024) f, _ := os.Open(\"/etc/passwd\") defer f.Close() for { n, _ := f.Read(buf) if n == 0 { break } os.Stdout.Write(buf[:n]) } } 方法二 func main() { fi, err := os.Open(\"/etc/passwd\") if err != nil { panic(err) } defer fi.Close() fd, err := ioutil.ReadAll(fi) fmt.Println(string(fd)) }                Gopher ","wordCount":"1182","inLanguage":"en","datePublished":"2017-06-23T05:13:00Z","dateModified":"2017-06-23T05:13:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://phpgao.github.io/golang.html"},"publisher":{"@type":"Organization","name":"老高的技术博客","logo":{"@type":"ImageObject","url":"https://phpgao.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://phpgao.github.io/ accesskey=h title="老高的博客 (Alt + H)">老高的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://phpgao.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://phpgao.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://blog.phpgao.com title="old blog"><span>old blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://phpgao.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://phpgao.github.io/posts/>Posts</a></div><h1 class=post-title>Golang简介</h1><div class=post-meta>June 23, 2017&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2017-06-23_golang.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=golang简介>Golang简介<a hidden class=anchor aria-hidden=true href=#golang简介>#</a></h1><p><img loading=lazy src=http://ww2.sinaimg.cn/large/0060lm7Tgw1fbes02kxgsj302s02s3yc.jpg alt=logo></p><hr><h2 id=why-golang>Why Golang?<a hidden class=anchor aria-hidden=true href=#why-golang>#</a></h2><blockquote><p><a href=http://blog.codingnow.com/2010/11/go_prime.html>我发现我花了四年时间锤炼自己用 C 语言构建系统的能力，试图找到一个规范，可以更好的编写软件。结果发现只是对 Go 的模仿。缺乏语言层面的支持，只能是一个拙劣的模仿。</a> &mdash; 吴云洋(云风的 BLOG)</p></blockquote><hr><h2 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h2><ul><li>并行</li><li>快速</li><li>UTF-8</li><li>跨平台</li></ul><hr><h2 id=配置运行环境>配置运行环境<a hidden class=anchor aria-hidden=true href=#配置运行环境>#</a></h2><h3 id=下载安装>下载安装<a hidden class=anchor aria-hidden=true href=#下载安装>#</a></h3><p>官网下载地址 <a href=https://golang.org/dl/>https://golang.org/dl/</a></p><p>下载文件并执行安装，Linux系统只需要解压即可！</p><p><a href="https://store.docker.com/images/3e4f3e51-3930-4dd8-975c-517705d9d4e7?tab=description">Docker&ndash;Golang</a></p><blockquote><p>tips 命令行<code>godoc -http=:8081</code> 可以查看离线文档</p></blockquote><h3 id=配置>配置<a hidden class=anchor aria-hidden=true href=#配置>#</a></h3><p>指定GOPATH为将要工作的目录，然后将bin添加到PATH中，输入命令<code>go env</code>查看</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>GOARCH=&#34;amd64&#34;   ---架构
GOBIN=&#34;&#34;         ---编译好的文件
GOEXE=&#34;&#34;  
GOHOSTARCH=&#34;amd64&#34;
GOHOSTOS=&#34;darwin&#34;
GOOS=&#34;darwin&#34;  --系统
GOPATH=&#34;/Users/gaozhimin/work&#34;  --工作目录
GORACE=&#34;&#34;
GOROOT=&#34;/usr/local/go&#34;     --go的安装目录
GOTOOLDIR=&#34;/usr/local/go/pkg/tool/darwin_amd64&#34;
CC=&#34;clang&#34;
GOGCCFLAGS=&#34;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/qy/y1gwdk9x425f4nn60278ncp00000gn/T/go-build689949734=/tmp/go-build -gno-record-gcc-switches -fno-common&#34;
CXX=&#34;clang++&#34;
CGO_ENABLED=&#34;1&#34;
</code></pre></div><h3 id=编辑器>编辑器<a hidden class=anchor aria-hidden=true href=#编辑器>#</a></h3><p>推荐使用</p><ul><li><a href=https://code.visualstudio.com>vscode</a></li><li><a href=http://www.sublimetext.com/3>sublime3</a></li><li><a href=https://atom.io>atom</a></li><li><a href=https://sourceforge.net/projects/liteide/>liteide</a></li></ul><hr><h2 id=基本语法>基本语法<a hidden class=anchor aria-hidden=true href=#基本语法>#</a></h2><h3 id=hello_world>HELLO_WORLD<a hidden class=anchor aria-hidden=true href=#hello_world>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 一个文件夹内只能有一个包名
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#75715e>// P在⬇️此处大写，注意
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello world!&#34;</span>)
	<span style=color:#75715e>// 普通字符使用双引号
</span><span style=color:#75715e></span>}
</code></pre></div><p>Golang的双引号和反引号都可用于表示一个常量字符串，不同在于：</p><ul><li>双引号用来创建可解析的字符串字面量(支持转义，但不能用来引用多行)</li><li>反引号用来创建原生的字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式</li></ul><h3 id=变量声明>变量声明<a hidden class=anchor aria-hidden=true href=#变量声明>#</a></h3><blockquote><p>类型在变量的后面</p></blockquote><h3 id=例子>例子<a hidden class=anchor aria-hidden=true href=#例子>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>var a int
var b bool
// := 等价于 var 后赋值
c := 5

var (
    e int
    f bool
)
g := `Linkin
    Park`

const x = 42

const (
    y = 1
    b = &#34;&#34;
)
</code></pre></div><h3 id=基本类型>基本类型<a hidden class=anchor aria-hidden=true href=#基本类型>#</a></h3><ul><li>int，Runes（注：Rune 是int 的别名）</li><li>int8 ,int16 ,int32 ,int64</li><li>byte ,uint8 ,uint16 ,uint32 ,uint64 （注：byte是uint8 的别名）</li><li>float32 ，float64 (没有float 类型)</li><li>bool</li><li>string</li><li>complex128，complex64</li></ul><hr><h2 id=保留关键字>保留关键字<a hidden class=anchor aria-hidden=true href=#保留关键字>#</a></h2><p>break case chan const continue default func defer go else goto fallthrough if for import interface map package range return select struct switch type var</p><h3 id=对比php>对比PHP<a hidden class=anchor aria-hidden=true href=#对比php>#</a></h3><p><img loading=lazy src=http://ww2.sinaimg.cn/large/0060lm7Tgw1fbes6qgq9wj30nu0e7ady.jpg alt=PHP></p><hr><h2 id=控制结构>控制结构<a hidden class=anchor aria-hidden=true href=#控制结构>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// if
if err := Chmod(0664); err != nil {
    // 注意err的作用于
	fmt.Printf(err)
	return err
}

// for
sum := 0
for i := 0; i &lt; 10; i++ {
	sum += i
}

//循环中的break和continue

for{
    // 如果不加break，就是一个完美的死循环
    break
}

for pos, char := range &#34;abc&#34; {
    fmt.Printf(&#34;character &#39;%c&#39; starts at byte position %d\n&#34;, char, pos)
}

// switch

var i int
switch i {
case 0:
case 1:
	f()
default:
	g() //当i不等于0或1时调用
}
</code></pre></div><hr><h2 id=复合类型>复合类型<a hidden class=anchor aria-hidden=true href=#复合类型>#</a></h2><p>array、slices 和 map</p><h3 id=array>array<a hidden class=anchor aria-hidden=true href=#array>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// 定长
var arr [10]int
// 长度不同类型不同
var a [10]int
var b [11]int
a = b //报错

// 传值不传址
</code></pre></div><h3 id=slice>slice<a hidden class=anchor aria-hidden=true href=#slice>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>// 长度可以改变
sl := make([]int, 10)
// 传地址
s1 := []int{1, 2, 3}
s2 := s1
fmt.Println(s2)
s1[0] = 0
fmt.Println(s2)
// [1 2 3]
// [0 2 3]
s3 := append(s3, 4)
fmt.Println(s3)
</code></pre></div><h3 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3><p>≈ python.map</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>newMap := map[int]string{
	0: &#34;Sun&#34;, 1: &#34;Mon&#34;,
	2: &#34;Tue&#34;, 3: &#34;Wed&#34;,
	4: &#34;Thu&#34;, 5: &#34;Fri&#34;,
	6: &#34;Sat&#34;,
}
// 查找键值是否存在
if v, ok := newMap[7]; ok {
	fmt.Println(v)
} else {
	fmt.Println(&#34;Key Not Found&#34;)
}
// Key Not Found
delete(newMap, 5)
fmt.Println(newMap)
</code></pre></div><hr><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><h3 id=作用域>作用域<a hidden class=anchor aria-hidden=true href=#作用域>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>6</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>p</span>()
	<span style=color:#a6e22e>q</span>()
	<span style=color:#a6e22e>p</span>()
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>p</span>() {
	println(<span style=color:#a6e22e>a</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>q</span>() {
	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>5</span>
	<span style=color:#75715e>// a = 5
</span><span style=color:#75715e></span>	println(<span style=color:#a6e22e>a</span>)
}
</code></pre></div><h3 id=返回格式>返回格式<a hidden class=anchor aria-hidden=true href=#返回格式>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>
// 函数参数 ip，类型为string
// 函数返回，conn和error
func connect(ip string) (conn *conn, err error){
    ...
    ...
    
    return
}

func connect(ip string) (*conn, error){
    conn := xxxx
    err := xxx
    
    return conn, err
}

// 接参数
con, err = connect(&#34;127.0.0.1&#34;)
if err != nil{
    panic(&#34;error&#34;)
}

// 忽略参数
_, err = connect(&#34;127.0.0.1&#34;)
if err != nil{
    panic(&#34;error&#34;)
}
</code></pre></div><h3 id=defer>Defer<a hidden class=anchor aria-hidden=true href=#defer>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func downloadFile(filepath string, url string) (err error) {

	// Create the file
	out, err := os.Create(filepath)
	if err != nil {
		return err
	}
	defer out.Close()

	// Get the data
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Writer the body to file
	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return err
	}

	return
}
</code></pre></div><h3 id=匿名函数>匿名函数<a hidden class=anchor aria-hidden=true href=#匿名函数>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	a := func() {
		fmt.Println(&#34;你好&#34;)
	}
	a()
}
</code></pre></div><h3 id=回调>回调<a hidden class=anchor aria-hidden=true href=#回调>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	callback(&#34;callback&#34;, print)
}
func print(s string) {
	fmt.Println(s)
}

func callback(s string, f func(string)) {
	f(s)
}
</code></pre></div><h3 id=恐慌和恢复>恐慌和恢复<a hidden class=anchor aria-hidden=true href=#恐慌和恢复>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	if throwsPanic(p) {
		fmt.Println(&#34;Panic Happened&#34;)
	}
}

//可能出现恐慌
func p() {
	panic(&#34;failed&#34;)
}

func throwsPanic(f func()) (b bool) {
    // defer在发生恐慌后能够执行，使用recover能捕捉到panic
	defer func() {
		if x := recover(); x != nil {
			b = true
		}
	}()
	f()
	return
}
</code></pre></div><hr><h2 id=包>包<a hidden class=anchor aria-hidden=true href=#包>#</a></h2><blockquote><p>包是函数和数据的集合。用 package 关键字定义一个包。每个文件都必须以package开头！</p></blockquote><h3 id=包名>包名<a hidden class=anchor aria-hidden=true href=#包名>#</a></h3><p>简洁明了，无下划线，无大小写混合，分隔符表示目录层级关系。</p><p>import的起点为</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>import (
	&#34;io&#34;
	&#34;net/http&#34;
	&#34;os&#34;
	
	&#34;github.com/laogao/tools/lib&#34;
)
</code></pre></div><p>net/http
net/http 实现了 HTTP 请求、响应和 URL 的解析，并且提供了可扩展的 HTTP 服 务和基本的 HTTP 客户端。</p><p>flag
flag 包实现了命令行解析。</p><p>os
os 包提供了与平台无关的操作系统功能接口。其设计是 Unix 形式的。</p><p>io
这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进 行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。</p><p><a href=https://golang.org/pkg/fmt/>fmt</a>
包 fmt 实现了格式化的 I/O 函数，这与 C 的 printf 和 scanf 类似。格式化短语 派生于 C 。</p><h3 id=首字母大小写>首字母大小写<a hidden class=anchor aria-hidden=true href=#首字母大小写>#</a></h3><p>名称以大写字母起始的是可导出(exported)的。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func Add(a, b int) int {
	return a + b
}

func hide(){
    xxxx
}
</code></pre></div><h3 id=工程目录>工程目录<a hidden class=anchor aria-hidden=true href=#工程目录>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>goWorkSpace     // goWorkSpace为GOPATH目录
  -- bin
     -- myApp1  // 编译生成
     -- myApp2  // 编译生成
     -- myApp3  // 编译生成
  -- pkg
  -- src
     -- common 1
     -- common 2
     -- common utils ...
     -- myApp1     // project1
        -- models
        -- controllers
        -- others
        -- main.go 
     -- myApp2     // project2
        -- models
        -- controllers
        -- others
        -- main.go 
     -- myApp3     // project3
        -- models
        -- controllers
        -- others
        -- main.go 
</code></pre></div><h3 id=获取第三方go包>获取第三方Go包<a hidden class=anchor aria-hidden=true href=#获取第三方go包>#</a></h3><p>以<a href=https://github.com/go-sql-driver/mysql>https://github.com/go-sql-driver/mysql</a>为例</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>go get github.com/go-sql-driver/mysql
</code></pre></div><h2 id=指针和结构体>指针和结构体<a hidden class=anchor aria-hidden=true href=#指针和结构体>#</a></h2><h3 id=指针>指针<a hidden class=anchor aria-hidden=true href=#指针>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	var i int
	i = 1
	var p *int
	p = &amp;i

	fmt.Printf(&#34;i=%d;p=%d;*p=%d\n&#34;, i, p, *p)

	*p = 2
	fmt.Printf(&#34;i=%d;p=%d;*p=%d\n&#34;, i, p, *p)

	i = 3
	fmt.Printf(&#34;i=%d;p=%d;*p=%d\n&#34;, i, p, *p)
}
</code></pre></div><h3 id=结构体>结构体<a hidden class=anchor aria-hidden=true href=#结构体>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>type foo int

func main() {
	var a foo
	a = 1
	fmt.Println(a)

	t1 := T{&#34;t1&#34;}

	fmt.Println(&#34;M1调用前：&#34;, t1.Name)
	t1.M1()
	fmt.Println(&#34;M1调用后：&#34;, t1.Name)

	fmt.Println(&#34;M2调用前：&#34;, t1.Name)
	t1.M2()
	fmt.Println(&#34;M2调用后：&#34;, t1.Name)
}

//想要使用结构体，可以在其类型上添加函数，也可以直接做参数传入函数中

type T struct {
	Name string
}

func (t T) M1() {
	t.Name = &#34;name1&#34;
}

func (t *T) M2() {
	t.Name = &#34;name2&#34;
}
</code></pre></div><h3 id=传值与传指针>传值与传指针<a hidden class=anchor aria-hidden=true href=#传值与传指针>#</a></h3><p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p><p>传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</p><p>Go语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）</p><p>要访问指针 p 指向的结构体中某个元素 x，不需要显式地使用 * 运算，可以直接 p.x</p><h2 id=接口>接口<a hidden class=anchor aria-hidden=true href=#接口>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>apple</span> <span style=color:#66d9ef>struct</span> {
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>pineapple</span> <span style=color:#66d9ef>struct</span> {
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#a6e22e>apple</span>) <span style=color:#a6e22e>eat</span>() {
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;I&#39;m an apple,I can be eaten&#34;</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>pineapple</span>) <span style=color:#a6e22e>eat</span>() {
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;I&#39;m a pineapple,I can be eaten&#34;</span>)
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>eatable</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>eat</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>apple</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>apple</span>{}
	<span style=color:#a6e22e>pineapple</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>pineapple</span>)
	<span style=color:#a6e22e>eat</span>(<span style=color:#a6e22e>apple</span>)
	<span style=color:#a6e22e>eat</span>(<span style=color:#a6e22e>pineapple</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>eat</span>(<span style=color:#a6e22e>sth</span> <span style=color:#a6e22e>eatable</span>) {
	<span style=color:#a6e22e>sth</span>.<span style=color:#a6e22e>eat</span>()
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>sth</span>.(<span style=color:#66d9ef>type</span>) {
	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>pineapple</span>:
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Got a pineapple&#34;</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>apple</span>:
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Got a apple&#34;</span>)
	}
}
</code></pre></div><h2 id=gc>GC<a hidden class=anchor aria-hidden=true href=#gc>#</a></h2><p>设想你正在编写一个长期运行的后台服务，就让它是一个 web 应用服务或者某些更复杂的东西。通常来说，在整个运行周期都会需要分配内存。了解如何处理这些内存是必要的。</p><p>通常，每 2 分钟会执行一次垃圾收集。如果某个片段持续 5 分钟都没有被使用，回收器会将其释放。</p><p>因此，如果你认为内存使用会降低，那么 7 分钟之后再去确认吧。</p><p>更多关于GC优化，可以浏览<a href=https://blog.twitch.tv/gos-march-to-low-latency-gc-a6fa96f06eb7#.akvcillrd>Go’s march to low-latency GC</a></p><hr><h2 id=并发>并发<a hidden class=anchor aria-hidden=true href=#并发>#</a></h2><h3 id=goroutine>goroutine<a hidden class=anchor aria-hidden=true href=#goroutine>#</a></h3><blockquote><p>goroutine不是线程、协程、进程等等，传递了不准确的含义。goroutine 有简单的模型:它是与其他 goroutine 并行执行的， 有着相同地址空间的函数。它是轻量的，仅比分配栈空间多一点点。 而初始时栈是很小的，所以它们也是廉价的，并且随着需要在堆空间上分 配(和释放)。</p></blockquote><p>使用go关键字让一个函数以goroutine方式执行</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func echo(s string) {
	fmt.Println(s)
}

func main() {
	echo(&#34;hi&#34;)
	go echo(&#34;hi&#34;)
	
	// time.Sleep(5 * time.Second)
}

//猜测一下回打印出什么？为什么？
</code></pre></div><h3 id=channel>channel<a hidden class=anchor aria-hidden=true href=#channel>#</a></h3><p>如果不考虑go出去的函数，那么程序就会执行完毕并退出，goroutine也会随之停止，需要引入一个通讯机制，他就是channel。</p><p>channel ≈ pipe</p><blockquote><p>channel必须使用make关键字创建</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>c1 := make(chan int)

// channel可以有长度
c2 := make(chan string, 100)

//channel的使用方法

c1 &lt;- 1 //把int 1 放入 c1
&lt;-c1 //尝试从c1取值
a := &lt;-c1 //取值并赋变量a
</code></pre></div><h3 id=结合>结合<a hidden class=anchor aria-hidden=true href=#结合>#</a></h3><p>在goroutine中我们把一个值写入chan，然后在主进程中尝试从chan中读取数据，如果此时chan中没有数据，程序会被阻塞，只到有值取出。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>var c chan int

func ready(w string, sec int) {
	time.Sleep(time.Duration(sec) * time.Second)
	fmt.Println(w, &#34;is ready!&#34;)
	c &lt;- 1
}

func main() {
	c = make(chan int)
	go ready(&#34;Tea&#34;, 2)
	go ready(&#34;Coffee&#34;, 1)
	fmt.Println(&#34;I&#39;m waiting, but not too long&#34;)
	&lt;-c
	&lt;-c
}
</code></pre></div><p>上面的例子是已经提前知道go出去的goroutine的个数才会这样写，当我们不知道个数的时候呢？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	c = make(chan int)
	go ready(&#34;Tea&#34;, 2)
	go ready(&#34;Coffee&#34;, 1)
	i := 0
	
	//跳转标记L
L:
	for {
		select {
		case &lt;-c:

			i++
			if i &gt; 1 {
				break L
			}
		}
	}
}
</code></pre></div><h3 id=超时机制>超时机制<a hidden class=anchor aria-hidden=true href=#超时机制>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	c = make(chan string)
	timeout = make(chan bool)
	go ready(&#34;Tea&#34;, 6)
	go ready(&#34;Coffee&#34;, 1)
	go func() {
		time.Sleep(time.Second * 3) // 5 秒超时
		timeout &lt;- true
	}()
	fmt.Println(&#34;I&#39;m waiting, but not too long&#34;)

L:
	for {
		select {
		case done := &lt;-c:
			fmt.Println(done, &#34;is ready!&#34;)
		case &lt;-timeout:
			fmt.Println(&#34;timeout&#34;)
			break L
		}
	}
}

</code></pre></div><h2 id=读取文件>读取文件<a hidden class=anchor aria-hidden=true href=#读取文件>#</a></h2><h3 id=方法一>方法一<a hidden class=anchor aria-hidden=true href=#方法一>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	buf := make([]byte, 1024)
	f, _ := os.Open(&#34;/etc/passwd&#34;)
	defer f.Close()
	for {
		n, _ := f.Read(buf)
		if n == 0 {
			break
		}
		os.Stdout.Write(buf[:n])
	}
}
</code></pre></div><h3 id=方法二>方法二<a hidden class=anchor aria-hidden=true href=#方法二>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>func main() {
	fi, err := os.Open(&#34;/etc/passwd&#34;)
	if err != nil {
		panic(err)
	}
	defer fi.Close()
	fd, err := ioutil.ReadAll(fi)
	fmt.Println(string(fd))
}
</code></pre></div><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><h2 id=gopher>Gopher<a hidden class=anchor aria-hidden=true href=#gopher>#</a></h2><p><img loading=lazy src=http://ww1.sinaimg.cn/large/0060lm7Tgw1fberyt01wxj308y02wwej.jpg alt=Gopher></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://phpgao.github.io/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://phpgao.github.io/system_ed2k.html><span class=title>« Prev Page</span><br><span>系统下载</span></a>
<a class=next href=https://phpgao.github.io/garageband_download.html><span class=title>Next Page »</span><br><span>GarageBand中官方课程官网下载地址</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://phpgao.github.io/>老高的技术博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>